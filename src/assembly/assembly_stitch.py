#!/usr/bin/env python3
"""
Stitch Assembly Script

This script performs Stitch template-based assembly on processed de novo sequencing results.
It requires summary CSV files generated by denovo_process.py as input and runs the Stitch
binary to assemble peptide sequences using template-based algorithms.

Pipeline Position:
    1. denovo_process.py → Generate summary CSV files
    2. [THIS SCRIPT] Stitch assembly using summary files → Assembly results
    3. Metric scripts analyze assembly results

Dependencies:
    - Stitch binary executable (download from https://github.com/snijderlab/stitch)
    - Summary CSV files from denovo_process.py
    - MGF spectral files
    - Stitch batch files for configuration

About Stitch:
    Stitch is a template-based assembly tool for proteomics short reads designed for
    de novo antibody sequencing and repertoire profiling. It uses sophisticated
    algorithms to assemble peptide sequences from MS/MS spectra.

Supported Tools:
    CasanovoV1, CasanovoV2, pi-HelixNovo, pi-PrimeNovo, AdaNovo, ContraNovo,
    DeepNovo, InstaNovo, PointNovo, PGPointNovo, SMSNet

Usage:
    python assembly_stitch.py --tool CasanovoV1 --input_path /path/to/summary --output_path /path/to/assembly --mgf_path /path/to/mgf --batchfiles_path /path/to/batchfiles
"""

import os
import argparse
import pandas as pd
import numpy as np
import subprocess
import statistics
import yaml
import json
import re
from typing import Dict, Optional, Any


class StitchConfigLoader:
    """Configuration loader for Assembly Stitch parameters."""
    
    def __init__(self, config_path: Optional[str] = None):
        """
        Initialize configuration loader.
        
        Args:
            config_path: Path to configuration file. If None, uses default path.
        """
        if config_path is None:
            # Default config path is in the src/config directory
            script_dir = os.path.dirname(os.path.abspath(__file__))
            # Go up one level from assembly to src, then into config
            src_dir = os.path.dirname(script_dir)
            config_path = os.path.join(src_dir, 'config', 'assembly_stitch.yaml')
        
        self.config_path = config_path
        self.config = self._load_config()
        
        # Get project root directory for resolving relative paths
        self.project_root = self._get_project_root()
    
    def _load_config(self) -> Dict[str, Any]:
        """Load configuration from YAML file."""
        try:
            with open(self.config_path, 'r', encoding='utf-8') as f:
                config = yaml.safe_load(f)
            print(f"Loaded configuration from {self.config_path}")
            return config
        except FileNotFoundError:
            print(f"Warning: Configuration file {self.config_path} not found. Using fallback defaults.")
            return self._get_fallback_config()
        except yaml.YAMLError as e:
            print(f"Error parsing YAML config: {e}. Using fallback defaults.")
            return self._get_fallback_config()
    
    def _get_project_root(self) -> str:
        """Get project root directory."""
        # Start from script directory and go up to find project root
        script_dir = os.path.dirname(os.path.abspath(__file__))
        # Go up two levels: assembly -> src -> project_root
        project_root = os.path.dirname(os.path.dirname(script_dir))
        return project_root
    
    def _resolve_path(self, relative_path: str) -> str:
        """Resolve relative path to absolute path based on project root."""
        if os.path.isabs(relative_path):
            return relative_path
        return os.path.join(self.project_root, relative_path)

    def _get_fallback_config(self) -> Dict[str, Any]:
        """Get fallback configuration if config file is not available."""
        return {
            'tool_names': [
                'CasanovoV1', 'CasanovoV2', 'pi-HelixNovo', 'pi-PrimeNovo', 
                'AdaNovo', 'ContraNovo', 'DeepNovo', 'InstaNovo',
                'PointNovo', 'PGPointNovo', 'SMSNet'
            ],
            'default_names': {
                '50ugmAb1': 'mAb1',
                '100ugmAb2': 'mAb2',
                '200ugmAb3': 'mAb3',
                '20230210-mAb4': 'mAb4',
                '20230707-mAb5': 'mAb5',
                '20231203-mAb6': 'mAb6',
                '20231221-mAb7': 'mAb7',
                '20250415-mAb8': 'mAb8'
            },
            'default_parameters': {
                'quality_cutoff': 90,
                'confidence_threshold_suffix': '_90'
            },
            'default_paths': {
                'stitch_binary': 'stitch-v1.5.0-linux/stitch.bin',
                'confidence_threshold_file': 'data/Tool_Confidence_Threshold_90.csv',
                'batchfiles_dir': 'stitch-v1.5.0-linux/batchfiles'
            },
            'base_paths': {
                'denovo_results_base': 'denovo',
                'mgf_files_base': 'monoclonal_antibody',
                'output_base': 'Stitch_Assembly'
            },
            'default_confidence_thresholds': {tool: 90 for tool in [
                'CasanovoV1', 'CasanovoV2', 'pi-HelixNovo', 'pi-PrimeNovo', 
                'AdaNovo', 'ContraNovo', 'DeepNovo', 'InstaNovo',
                'PointNovo', 'PGPointNovo', 'SMSNet'
            ]}
        }
    
    @property
    def tool_names(self) -> set:
        """Get supported tool names."""
        return set(self.config.get('tool_names', []))
    
    @property
    def default_names(self) -> Dict[str, str]:
        """Get default antibody name mapping."""
        return self.config.get('default_names', {})
    
    @property
    def default_parameters(self) -> Dict[str, Any]:
        """Get default processing parameters."""
        return self.config.get('default_parameters', {})
    
    @property
    def mass_constants(self) -> Dict[str, Any]:
        """Get mass constants for peptide calculations."""
        return self.config.get('mass_constants', {})
    
    @property
    def default_paths(self) -> Dict[str, str]:
        """Get default file paths (resolved to absolute paths)."""
        paths = self.config.get('default_paths', {})
        resolved_paths = {}
        for key, path in paths.items():
            resolved_paths[key] = self._resolve_path(path)
        return resolved_paths
    
    @property
    def base_paths(self) -> Dict[str, str]:
        """Get base directory paths (resolved to absolute paths)."""
        paths = self.config.get('base_paths', {})
        resolved_paths = {}
        for key, path in paths.items():
            resolved_paths[key] = self._resolve_path(path)
        return resolved_paths
    
    @property
    def tool_file_patterns(self) -> Dict[str, Dict[str, Any]]:
        """Get tool-specific file patterns."""
        return self.config.get('tool_file_patterns', {})
    
    @property
    def tool_input_dirs(self) -> Dict[str, str]:
        """Get tool-specific input directory mapping."""
        return self.config.get('tool_input_dirs', {})
    
    @property
    def mgf_file_pattern(self) -> str:
        """Get MGF file pattern."""
        return self.config.get('mgf_file_pattern', 'spectrum_{sample_name}_HCD.mgf')
    
    @property
    def mgf_subdir(self) -> str:
        """Get MGF subdirectory."""
        return self.config.get('mgf_subdir', 'process1')
    
    @property
    def batchfile_pattern(self) -> str:
        """Get batchfile pattern."""
        return self.config.get('batchfile_pattern', '{mab}.txt')
    
    @property
    def excluded_mab_patterns(self) -> list:
        """Get patterns to exclude from mAb processing."""
        return self.config.get('excluded_mab_patterns', [])
    
    @property
    def default_confidence_thresholds(self) -> Dict[str, int]:
        """Get default confidence thresholds."""
        return self.config.get('default_confidence_thresholds', {})
    
    @property
    def stitch_columns(self) -> list:
        """Get Stitch CSV output column names."""
        return self.config.get('stitch_columns', [])


# Global configuration loader
_stitch_config_loader = None

def get_stitch_config_loader(config_path: Optional[str] = None) -> StitchConfigLoader:
    """Get global configuration loader instance."""
    global _stitch_config_loader
    if _stitch_config_loader is None or config_path is not None:
        _stitch_config_loader = StitchConfigLoader(config_path)
    return _stitch_config_loader


class AssemblyStitch:
    """Assembly Stitch processor for various de novo sequencing tools."""
    
    def __init__(self, confidence_threshold_file: Optional[str] = None, stitch_binary_path: Optional[str] = None, 
                 batchfiles_dir: Optional[str] = None, config_path: Optional[str] = None):
        """
        Initialize the Assembly Stitch processor.
        
        Args:
            confidence_threshold_file: Path to the CSV file containing confidence thresholds
            stitch_binary_path: Path to the stitch.bin file
            batchfiles_dir: Path to the batchfiles directory
            config_path: Path to configuration file
        """
        # Load configuration
        self.config = get_stitch_config_loader(config_path)
        
        # Set paths from config or arguments
        default_paths = self.config.default_paths
        self.stitch_binary_path = stitch_binary_path or default_paths.get('stitch_binary', 'stitch-v1.5.0-linux/stitch.bin')
        self.batchfiles_dir = batchfiles_dir or default_paths.get('batchfiles_dir', 'stitch-v1.5.0-linux/batchfiles')
        
        # Set default parameters from config
        default_params = self.config.default_parameters
        self.quality_cutoff = default_params.get('quality_cutoff', 90)
        
        # Load mass constants
        mass_constants = self.config.mass_constants
        self.mass_H = mass_constants.get('mass_H', 1.0078)
        self.mass_N_terminus = mass_constants.get('mass_N_terminus', 1.0078)
        self.mass_C_terminus = mass_constants.get('mass_C_terminus', 17.0027)
        self.mass_AA = mass_constants.get('mass_AA', {})
        
        # Load confidence thresholds
        confidence_file = confidence_threshold_file or default_paths.get('confidence_threshold_file')
        if confidence_file and os.path.exists(confidence_file):
            df = pd.read_csv(confidence_file)
            self.score_all = pd.Series(df.Confidence_Threshold.values, index=df.Tool).to_dict()
        else:
            # Use default thresholds from config
            self.score_all = self.config.default_confidence_thresholds
    
    def _extract_mgf_metadata(self, mgf_file: str) -> Dict[str, list]:
        """Extract metadata from MGF file."""
        titles = []
        exp_mass_to_charge = []
        charge = []
        RT = []
        
        try:
            with open(mgf_file, 'r') as fr:
                lines = fr.readlines()
                for line in lines:
                    if 'TITLE=' in line:
                        titles.append(line.strip().split('TITLE=')[-1])
                    elif 'PEPMASS=' in line:
                        exp_mass_to_charge.append(line.strip().split('PEPMASS=')[-1])
                    elif 'CHARGE=' in line:
                        charge.append(line.strip().split('CHARGE=')[-1])
                    elif 'RTINSECONDS=' in line:
                        RT.append(line.strip().split('RTINSECONDS=')[-1])
        except FileNotFoundError:
            print(f"Warning: MGF file {mgf_file} not found.")
            return {'titles': [], 'exp_mass_to_charge': [], 'charge': [], 'RT': []}
        
        # Convert to appropriate types
        exp_mass_to_charge = [float(i) for i in exp_mass_to_charge]
        charge = [int(re.match(r'\d+', i).group()) for i in charge]
        RT = [float(i) for i in RT]
        
        return {
            'titles': titles,
            'exp_mass_to_charge': exp_mass_to_charge,
            'charge': charge,
            'RT': RT
        }
    
    def _calculate_mass_and_ppm(self, sequences: list, exp_mass_to_charge: list, charge: list) -> tuple:
        """Calculate peptide masses and ppm errors."""
        Mass_peptide = []
        for seq in sequences:
            try:
                mass = sum(self.mass_AA.get(aa, 0) for aa in seq) + self.mass_N_terminus + self.mass_C_terminus
                Mass_peptide.append(mass)
            except Exception:
                Mass_peptide.append(0)
        
        Mass_exp = [
            exp_mass_to_charge[i] * charge[i] - charge[i] * self.mass_H 
            for i in range(len(exp_mass_to_charge))
        ]
        
        ppm = [
            10**6 * (Mass_exp[i] - Mass_peptide[i]) / Mass_peptide[i] if Mass_peptide[i] > 0 else 0
            for i in range(len(Mass_peptide))
        ]
        
        return Mass_peptide, ppm
    
    def _create_stitch_dataframe(self, data_dict: Dict[str, list]) -> pd.DataFrame:
        """Create standardized Stitch output DataFrame."""
        num_rows = len(data_dict['PSM_ID'])
        columns = self.config.stitch_columns
        
        DF = np.empty((num_rows, len(columns)), dtype='object')
        
        # Map data to specific columns
        DF[:, 1] = data_dict['PSM_ID']           # Source File
        DF[:, 3] = data_dict['sequence']         # Peptide
        DF[:, 4] = data_dict['PSM_ID']           # Scan
        DF[:, 5] = data_dict['length']           # Tag Length
        DF[:, 6] = data_dict['Score']            # Denovo Score
        DF[:, 7] = data_dict['Score']            # ALC (%)
        DF[:, 8] = data_dict['length']           # length
        DF[:, 9] = data_dict['exp_mass_to_charge']  # m/z
        DF[:, 10] = data_dict['charge']          # z
        DF[:, 11] = data_dict['RT']              # RT
        DF[:, 12] = ['-'] * num_rows             # Predict RT
        DF[:, 13] = [1] * num_rows               # Area
        DF[:, 14] = data_dict['Mass_peptide']    # Mass
        DF[:, 15] = data_dict['ppm']             # ppm
        DF[:, 17] = data_dict['aascore']         # local confidence (%)
        DF[:, 18] = data_dict['sequence']        # tag (>=0%)
        DF[:, 19] = ['HCD'] * num_rows           # mode
        
        df = pd.DataFrame(DF, columns=columns)
        return df
    
    def _update_batchfile(self, batchfile_path: str, output_csv: str, resultdir: str, quality_cutoff_local: int) -> str:
        """Update batchfile with new CSV path and cutoff."""
        try:
            with open(batchfile_path, 'r') as fr:
                lines = fr.readlines()
            
            newfile = os.path.join(resultdir, os.path.basename(batchfile_path))
            
            with open(newfile, 'w') as fw:
                for line in lines:
                    if 'Path     : ' in line:
                        fw.write(line.replace(line.split('Path     : ')[-1].strip(), output_csv + '\n'))
                    elif 'CutoffALC: ' in line:
                        # Extract current cutoff and replace with new one
                        current_cutoff = line.split('CutoffALC: ')[-1].strip()
                        fw.write(line.replace(current_cutoff, str(quality_cutoff_local) + '\n'))
                    else:
                        fw.write(line)
            
            return newfile
        except FileNotFoundError:
            print(f"Warning: Batchfile {batchfile_path} not found.")
            return ""
    
    def _run_stitch_assembly(self, batchfile_path: str) -> None:
        """Run Stitch assembly using binary."""
        if not batchfile_path or not os.path.exists(batchfile_path):
            print(f"Warning: Batchfile {batchfile_path} not found.")
            return
        
        try:
            subprocess.run(
                [self.stitch_binary_path, 'run', batchfile_path],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.PIPE,
                check=True
            )
        except subprocess.CalledProcessError as e:
            print(f"Warning: Stitch assembly failed for {batchfile_path}: {e}")
        except FileNotFoundError:
            print(f"Warning: Stitch binary not found at {self.stitch_binary_path}")
    
    def process_casanovo_v1(self, casanovo_path: str, mgf_file: str, batchfile_dir: str, resultdir: str) -> None:
        """Process CasanovoV1 results for Stitch assembly."""
        tool = 'CasanovoV1'
        quality_cutoff_local = self.score_all.get(tool, 90)
        
        # Extract MGF metadata
        mgf_data = self._extract_mgf_metadata(mgf_file)
        
        casanovo_out = os.path.join(resultdir, f'{tool}_confScoreThreshold_{self.quality_cutoff}_localScore_{quality_cutoff_local}.csv')
        
        # Find header line
        casanovo_header = 0
        try:
            with open(casanovo_path) as f:
                for i, line in enumerate(f):
                    if line.startswith("PSH"):
                        casanovo_header = i
                        break
        except FileNotFoundError:
            print(f"Warning: Input file {casanovo_path} not found.")
            return
        
        # Load and process data
        df_deno = pd.read_csv(casanovo_path, sep="\t", header=casanovo_header)
        df_denovo = df_deno[df_deno['sequence'].notna()].copy()
        
        if df_denovo.empty:
            print(f"Warning: No valid sequences found in {casanovo_path}")
            return
        
        df_denovo['PSM_ID'] = df_denovo['PSM_ID'].astype(int)
        
        # Map MGF data
        df_denovo['exp_mass_to_charge'] = df_denovo['PSM_ID'].apply(
            lambda x: mgf_data['exp_mass_to_charge'][x] if x < len(mgf_data['exp_mass_to_charge']) else None)
        df_denovo['charge'] = df_denovo['PSM_ID'].apply(
            lambda x: mgf_data['charge'][x] if x < len(mgf_data['charge']) else None)
        df_denovo['RT'] = df_denovo['PSM_ID'].apply(
            lambda x: mgf_data['RT'][x] if x < len(mgf_data['RT']) else None)
        df_denovo['PSM_ID'] = df_denovo['PSM_ID'].apply(
            lambda x: mgf_data['titles'][x] if x < len(mgf_data['titles']) else None)
        
        # Process sequences and scores
        sequence = df_denovo['sequence'].tolist()
        PSM_ID = df_denovo['PSM_ID'].tolist()
        Score = [int((i * 100 + 100)/2) for i in df_denovo['search_engine_score[1]'].tolist()]
        
        # Process amino acid scores
        aascore = df_denovo['opt_ms_run[1]_aa_scores'].tolist()
        aascore = [str(i).replace(',', ' ') for i in aascore]
        aascore = [i.split() for i in aascore]
        aascore = [[str(int(float(j) * 100)) for j in i] for i in aascore]
        aascore = [" ".join(i) for i in aascore]
        
        # Convert sequences for mass calculation
        seq = [str(i).replace('M(+15.99)', 'm').replace('Q(+.98)', 'q').replace('N(+.98)', 'n')
               .replace('Q(-17.03)', 'q').replace(' ', '').replace('C(+57.02)', 'C') for i in sequence]
        length = [len(x) for x in seq]
        
        # Calculate masses and ppm
        Mass_peptide, ppm = self._calculate_mass_and_ppm(seq, df_denovo['exp_mass_to_charge'].tolist(), 
                                                        df_denovo['charge'].tolist())
        
        # Create data dictionary
        data_dict = {
            'PSM_ID': PSM_ID,
            'sequence': sequence,
            'Score': Score,
            'length': length,
            'exp_mass_to_charge': df_denovo['exp_mass_to_charge'].tolist(),
            'charge': df_denovo['charge'].tolist(),
            'RT': df_denovo['RT'].tolist(),
            'Mass_peptide': Mass_peptide,
            'ppm': ppm,
            'aascore': aascore
        }
        
        # Create and filter output DataFrame
        df = self._create_stitch_dataframe(data_dict)
        df['Denovo Score'] = df['Denovo Score'].astype(int)
        df = df[df['Denovo Score'] >= quality_cutoff_local]
        df.to_csv(casanovo_out, index=False)
        
        # Update batchfile and run Stitch
        batchfile_path = os.path.join(batchfile_dir, self.config.batchfile_pattern.format(mab=os.path.basename(resultdir)))
        new_batchfile = self._update_batchfile(batchfile_path, casanovo_out, resultdir, quality_cutoff_local)
        self._run_stitch_assembly(new_batchfile)
    
    def process_casanovo_v2(self, casanovo_path: str, mgf_file: str, batchfile_dir: str, resultdir: str) -> None:
        """Process CasanovoV2 results for Stitch assembly."""
        tool = 'CasanovoV2'
        quality_cutoff_local = self.score_all.get(tool, 90)
        
        # Extract MGF metadata
        mgf_data = self._extract_mgf_metadata(mgf_file)
        
        casanovo_out = os.path.join(resultdir, f'{tool}_confScoreThreshold_{self.quality_cutoff}_localScore_{quality_cutoff_local}.csv')
        
        # Find header line
        casanovo_header = 0
        try:
            with open(casanovo_path) as f:
                for i, line in enumerate(f):
                    if line.startswith("PSH"):
                        casanovo_header = i
                        break
        except FileNotFoundError:
            print(f"Warning: Input file {casanovo_path} not found.")
            return
        
        # Load and process data
        df_deno = pd.read_csv(casanovo_path, sep="\t", header=casanovo_header)
        df_denovo = df_deno[df_deno['sequence'].notna()].copy()
        
        if df_denovo.empty:
            print(f"Warning: No valid sequences found in {casanovo_path}")
            return
        
        df_denovo['PSM_ID'] = [int(item.replace('ms_run[1]:index=', '')) for item in df_denovo['spectra_ref']]
        
        # Map MGF data
        df_denovo['exp_mass_to_charge'] = df_denovo['PSM_ID'].apply(
            lambda x: mgf_data['exp_mass_to_charge'][x] if x < len(mgf_data['exp_mass_to_charge']) else None)
        df_denovo['charge'] = df_denovo['PSM_ID'].apply(
            lambda x: mgf_data['charge'][x] if x < len(mgf_data['charge']) else None)
        df_denovo['RT'] = df_denovo['PSM_ID'].apply(
            lambda x: mgf_data['RT'][x] if x < len(mgf_data['RT']) else None)
        df_denovo['PSM_ID'] = df_denovo['PSM_ID'].apply(
            lambda x: mgf_data['titles'][x] if x < len(mgf_data['titles']) else None)
        
        # Process sequences and scores
        sequence = df_denovo['sequence'].tolist()
        PSM_ID = df_denovo['PSM_ID'].tolist()
        Score = [int((i * 100 + 100)/2) for i in df_denovo['search_engine_score[1]'].tolist()]
        
        # Process amino acid scores
        aascore = df_denovo['opt_ms_run[1]_aa_scores'].tolist()
        aascore = [str(i).replace(',', ' ') for i in aascore]
        aascore = [i.split() for i in aascore]
        aascore = [[str(int(float(j) * 100)) for j in i] for i in aascore]
        aascore = [" ".join(i) for i in aascore]
        
        # Convert sequences for mass calculation
        seq = [str(i).replace('M(+15.99)', 'm').replace('Q(+.98)', 'q').replace('N(+.98)', 'n')
               .replace('Q(-17.03)', 'q').replace(' ', '').replace('C(+57.02)', 'C') for i in sequence]
        length = [len(x) for x in seq]
        
        # Calculate masses and ppm
        Mass_peptide, ppm = self._calculate_mass_and_ppm(seq, df_denovo['exp_mass_to_charge'].tolist(), 
                                                        df_denovo['charge'].tolist())
        
        # Create data dictionary
        data_dict = {
            'PSM_ID': PSM_ID,
            'sequence': sequence,
            'Score': Score,
            'length': length,
            'exp_mass_to_charge': df_denovo['exp_mass_to_charge'].tolist(),
            'charge': df_denovo['charge'].tolist(),
            'RT': df_denovo['RT'].tolist(),
            'Mass_peptide': Mass_peptide,
            'ppm': ppm,
            'aascore': aascore
        }
        
        # Create and filter output DataFrame
        df = self._create_stitch_dataframe(data_dict)
        df['Denovo Score'] = df['Denovo Score'].astype(int)
        df = df[df['Denovo Score'] >= quality_cutoff_local]
        df.to_csv(casanovo_out, index=False)
        
        # Update batchfile and run Stitch
        batchfile_path = os.path.join(batchfile_dir, self.config.batchfile_pattern.format(mab=os.path.basename(resultdir)))
        new_batchfile = self._update_batchfile(batchfile_path, casanovo_out, resultdir, quality_cutoff_local)
        self._run_stitch_assembly(new_batchfile)
    
    def process_tool(self, tool: str, input_path: str, output_path: str, mgf_path: Optional[str] = None, 
                    batchfiles_path: Optional[str] = None, names_mapping: Optional[Dict[str, str]] = None) -> None:
        """
        Process a specific tool for all available samples.
        
        Args:
            tool: Tool name to process
            input_path: Base input path containing tool results
            output_path: Base output path for Stitch assembly
            mgf_path: Base path to MGF files
            batchfiles_path: Path to batchfiles directory
            names_mapping: Mapping from directory names to sample names
        """
        if tool not in self.config.tool_names:
            raise ValueError(f"Unknown tool: {tool}. Supported tools: {self.config.tool_names}")
        
        if names_mapping is None:
            names_mapping = self.config.default_names
        
        # Get tool-specific directory and file patterns from config
        tool_input_dirs = self.config.tool_input_dirs
        tool_file_patterns = self.config.tool_file_patterns
        
        tool_input_dir = tool_input_dirs.get(tool, tool.lower().replace('-', ''))
        tool_input_path = os.path.join(input_path, tool_input_dir)
        tool_output_path = os.path.join(output_path, tool)
        
        if not os.path.exists(tool_input_path):
            print(f"Warning: Input path {tool_input_path} does not exist")
            return
        
        mabs = os.listdir(tool_input_path)
        excluded_patterns = self.config.excluded_mab_patterns
        
        # Filter out excluded mabs
        mabs = [mab for mab in mabs if not any(pattern in mab for pattern in excluded_patterns)]
        
        for mab in mabs:
            print(f"Processing {tool} for {mab}")
            mab_input_path = os.path.join(tool_input_path, mab)
            mab_output_path = os.path.join(tool_output_path, mab)
            os.makedirs(mab_output_path, exist_ok=True)
            
            try:
                # Get file pattern for this tool
                file_pattern_info = tool_file_patterns.get(tool, {})
                input_file_pattern = file_pattern_info.get('input_file', '')
                input_subdir = file_pattern_info.get('input_subdir', '')
                
                # Build input file path
                if input_subdir:
                    input_file_base = os.path.join(mab_input_path, input_subdir)
                else:
                    input_file_base = mab_input_path
                
                # Format file pattern with variables
                sample_name = names_mapping.get(mab, mab)
                input_file_name = input_file_pattern.format(mab=mab, sample_name=sample_name)
                input_file = os.path.join(input_file_base, input_file_name)
                
                # Build MGF file path
                mgf_file = None
                if mgf_path:
                    mgf_pattern = self.config.mgf_file_pattern.format(sample_name=sample_name)
                    mgf_file = os.path.join(mgf_path, mab, self.config.mgf_subdir, mgf_pattern)
                
                # Build batchfile path
                batchfile_dir = batchfiles_path or self.batchfiles_dir
                
                # Call appropriate processing method
                if tool == 'CasanovoV1':
                    self.process_casanovo_v1(input_file, mgf_file, batchfile_dir, mab_output_path)
                elif tool == 'CasanovoV2':
                    self.process_casanovo_v2(input_file, mgf_file, batchfile_dir, mab_output_path)
                # Add other tools as needed...
                else:
                    print(f"Tool {tool} processing not yet implemented")
                    
            except Exception as e:
                print(f"Error processing {tool} for {mab}: {e}")
                continue


def main():
    """Main function to run Assembly Stitch."""
    parser = argparse.ArgumentParser(description='Assembly Stitch Script')
    
    # Load config first to get default values
    config = get_stitch_config_loader()
    default_params = config.default_parameters
    default_paths = config.default_paths
    
    parser.add_argument('--tool', type=str, required=True, choices=list(config.tool_names),
                       help='Tool to process')
    parser.add_argument('--input_path', type=str, required=True,
                       help='Base input path containing de novo results')
    parser.add_argument('--output_path', type=str, required=True,
                       help='Base output path for Stitch assembly results')
    parser.add_argument('--mgf_path', type=str, required=True,
                       help='Base path to MGF files')
    parser.add_argument('--batchfiles_path', type=str,
                       default=default_paths.get('batchfiles_dir'),
                       help='Path to batchfiles directory')
    parser.add_argument('--confidence_threshold_file', type=str,
                       default=default_paths.get('confidence_threshold_file'),
                       help='Path to CSV file containing confidence thresholds')
    parser.add_argument('--stitch_binary_path', type=str, 
                       default=default_paths.get('stitch_binary'),
                       help='Path to stitch.bin file')
    parser.add_argument('--names_mapping_file', type=str,
                       help='Path to JSON file containing names mapping')
    parser.add_argument('--config_path', type=str,
                       help='Path to configuration YAML file')
    parser.add_argument('--quality_cutoff', type=int, default=default_params.get('quality_cutoff', 90),
                       help='Quality cutoff threshold')

    args = parser.parse_args()

    # Load names mapping if provided
    names_mapping = None
    if args.names_mapping_file and os.path.exists(args.names_mapping_file):
        with open(args.names_mapping_file, 'r') as f:
            names_mapping = json.load(f)

    # Initialize Assembly Stitch processor with config
    stitch_processor = AssemblyStitch(
        confidence_threshold_file=args.confidence_threshold_file,
        stitch_binary_path=args.stitch_binary_path,
        batchfiles_dir=args.batchfiles_path,
        config_path=args.config_path
    )
    
    # Override parameters if provided
    stitch_processor.quality_cutoff = args.quality_cutoff

    # Create output directories
    os.makedirs(args.output_path, exist_ok=True)

    # Process the specified tool
    try:
        stitch_processor.process_tool(args.tool, args.input_path, args.output_path, 
                                    args.mgf_path, args.batchfiles_path, names_mapping)
        print(f"Successfully processed {args.tool}")
    except Exception as e:
        print(f"Error processing {args.tool}: {e}")
        return 1

    return 0


if __name__ == '__main__':
    exit(main())
